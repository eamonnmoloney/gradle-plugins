apply plugin: 'idea'


final kotlinVersion     = '0.4.68'         // http://repository.jetbrains.com/kotlin/org/jetbrains/kotlin/kotlin-compiler/
final gcontractsVersion = '1.2.10'         // http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.gcontracts%22%20AND%20a%3A%22gcontracts-core%22
final junitVersion      = '4.11'           // http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22junit%22%20AND%20a%3A%22junit%22
final spockVersion      = '0.7-groovy-1.8' // http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.spockframework%22%20AND%20a%3A%22spock-core%22

defaultTasks 'duplicates', 'clean', 'codenarc', 'groovydoc', 'build', 'about', 'install'


ext.codenarcRuleSetFiles = [ "$rootDir/codenarc.groovy" ]
ext.codenarcExtensions   = [ '**/*.groovy' ]
ext.codenarcSources      = project.subprojects.collect{[ "${ it.projectDir.name }/src/main/groovy",
                                                         "${ it.projectDir.name }/src/test/groovy" ]}.flatten()
apply from: 'file:codenarc/CodeNarc.gradle'


println ">> Running Gradle [${ project.gradle.gradleVersion }], Groovy [${ GroovySystem.version }], Java [${ System.getProperty( 'java.version' ) }]"


buildscript {
    repositories { mavenRepo url: 'http://evgenyg.artifactoryonline.com/evgenyg/repo/' }
    dependencies { classpath      "com.github.goldin.plugins.gradle:about:0.2-beta-3",
                                  "com.github.goldin.plugins.gradle:duplicates:0.2-beta-3" }
}


idea.project {
    jdkName = '1.7'
    ipr.withXml { provider -> provider.node.component.find { it.@name == 'VcsDirectoryMappings' }.mapping.@vcs = 'Git' }
}


idea.module {
    iml.withXml {
        provider ->
        provider.node.component.content.first().appendNode( 'excludeFolder', [ url : 'file://$MODULE_DIR$/out' ])
        provider.node.component.first().appendNode( 'orderEntry', [ type : 'library', name : 'Groovy', level: 'application' ])
    }
}


subprojects {

    Project p ->

    apply plugin: 'groovy'
    apply plugin: 'maven'
    apply plugin: 'idea'
    apply plugin: 'about'
    apply plugin: 'duplicates'


    sourceCompatibility = 1.6
    group               = 'com.github.goldin.plugins.gradle'


    clean { delete( "$rootDir/out", "$rootDir/build" ) }

    repositories {
        mavenRepo url: 'http://repository.jetbrains.com/kotlin/'
        mavenRepo url: 'http://evgenyg.artifactoryonline.com/evgenyg/repo/'
    }

    about        { includeDependencies = [ 'compile', 'runtime' ]
                   prefix              = '/' }
    duplicates   { configurations      = [ 'compile', 'runtime' ]
                   verbose             = true }

    dependencies {
        groovy      localGroovy()
        compile     gradleApi(),
                    "org.gcontracts:gcontracts-core:$gcontractsVersion"
        testCompile "junit:junit:$junitVersion"
        testCompile ( "org.spockframework:spock-core:$spockVersion" ) {
            exclude group: 'org.codehaus.groovy'
            exclude group: 'junit'
        }
    }

    jar { from files( "${ project.rootProject.projectDir }/license.txt" ) }

    idea.module {
        downloadSources = true
        downloadJavadoc = false
    }

    /**
     * Adding sources and groovydocs
     */

    task sourcesJar( type: Jar, dependsOn: classes ) {
        classifier = 'sources'
        from sourceSets.main.allSource
        from files( "${ project.rootProject.projectDir }/license.txt" )
    }

    task groovydocJar( type: Jar, dependsOn: groovydoc ) {
        classifier = 'javadoc'
        from groovydoc.destinationDir
        from files( "${ project.rootProject.projectDir }/license.txt" )
    }

    artifacts {
         archives sourcesJar
         archives groovydocJar
    }
}


subprojects.findAll{ it.name != 'common' }.each {
    Project p ->

    p.dependencies {
        compile     project( ':common' )
        testCompile project( ':common' )
    }

    p.processResources << {
        Copy processResourcesTask ->
        final gradleProperties = new File( processResourcesTask.destinationDir, "META-INF/gradle-plugins/${ p.name }.properties" )
        final properties       = validatePropertiesFile( p, gradleProperties )
        updatePropertiesFile( gradleProperties, properties, [ version : p.version ])
    }
}


project( ':kotlin' ) {
    duplicates   { fail = false; verbose = false }
    dependencies {
        compile "org.jetbrains.kotlin:kotlin-compiler:$kotlinVersion",
                "org.jetbrains.kotlin:kdoc:$kotlinVersion"
    }
}


project( ':teamcity' ) {
    idea.module {
        iml.withXml {
            provider ->
            provider.node.component.content.first().with {
                appendNode( 'excludeFolder', [ url : 'file://$MODULE_DIR$/deploy-teamcity-artifacts/.gradle' ])
                appendNode( 'excludeFolder', [ url : 'file://$MODULE_DIR$/deploy-teamcity-artifacts/gradle'  ])
                appendNode( 'excludeFolder', [ url : 'file://$MODULE_DIR$/deploy-teamcity-artifacts/build'   ])
            }
        }
    }
}


task wrapper( type: Wrapper ) { gradleVersion = '1.3-rc-2' }



private Properties validatePropertiesFile( Project p, File gradleProperties )
{
    assert gradleProperties
    assert gradleProperties.file, "[$gradleProperties.canonicalPath] can't be found"

    final properties = new Properties()

    gradleProperties.withReader { properties.load( it )}

    final String implementationClass = properties[ 'implementation-class' ]
    assert implementationClass, "Gradle properties [$gradleProperties.canonicalPath] contain no 'implementation-class'"

    final classFile = new File(( File ) p.compileGroovy.destinationDir,
                               implementationClass.replace( '.', '/' ) + '.class' )
    assert classFile.file, "File [$classFile.canonicalPath] referenced by [$implementationClass] " +
                           "in [$gradleProperties.canonicalPath] can't be found"
    properties
}


private void updatePropertiesFile ( File gradleProperties, Properties properties, Map<String, ?> newProperties )
{
    assert gradleProperties && gradleProperties.file
    assert properties       && newProperties

    final propertiesNames = properties.keySet()

    for ( String newProperty in newProperties.keySet())
    {
        assert ( ! ( newProperty in (( Set<String> ) propertiesNames ))), \
               "Property [$newProperty] already exists in $properties"

        properties[ newProperty ] = newProperties[ newProperty ]
    }

    gradleProperties.withWriter { properties.store( it, null )}
}